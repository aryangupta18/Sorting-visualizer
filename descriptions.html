<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Visualizer</title>
    <link rel="stylesheet" href="./css/styleD.css" />
</head>
<body>
    <h2 class="title" onclick="window.location.reload()">
        About Sorting Algorithms
    </h2>
    <div class="box">
        <h3>Bubble Sort</h3>
        <div class="content">
            Bubble sort is a basic algorithm for arranging a string of numbers or other elements in the correct order. The method works by examining each set of adjacent elements in the string, from left to right, switching their positions if they are out of order. The algorithm then repeats this process until it can run through the entire string and find no two elements that need to be swapped.
            <h4>Advantages of Bubble Sort:</h4>
            <ul>
                <li>
                    Bubble sort is easy to understand and implement.
                </li>
                <li>
                    It does not require any additional memory space.
                </li>
                <li>
                    It is a stable sorting algorithm, meaning that elements with the same key value maintain their relative order in the sorted output.
                </li>
            </ul>
            <h4>Disadvantages of Bubble Sort:</h4>
            <ul>
                <li>
                    Bubble sort has a time complexity of O(N2) which makes it very slow for large data sets.
                </li>
                <li>
                    Bubble sort is a comparison-based sorting algorithm, which means that it requires a comparison operator to determine the relative order of elements in the input data set. It can limit the efficiency of the algorithm in certain cases.
                </li>
            </ul>
            <h4>Complexity Analysis of Bubble Sort:</h4>
            <ul>
                <li>
                    Time Complexity: O(N2)
                </li>
                <li>
                    Auxiliary Space: O(1)
                </li>
            </ul>
            <a href="https://www.geeksforgeeks.org/bubble-sort/"><button>More about the algorithm</button></a>
        </div>
    </div>
    <div class="box">
        <h3>Selection Sort</h3>
        <div class="content">
            Selection sort is a simple and efficient sorting algorithm that works by repeatedly selecting the smallest (or largest) element from the unsorted portion of the list and moving it to the sorted portion of the list. 
            <h4>Advantages of Selection Sort:</h4>
            <ul>
                <li>
                    Simple and easy to understand.
                </li>
                <li>
                    Works well with small datasets.
                </li>
            </ul>
            <h4>Disadvantages of Selection Sort:</h4>
            <ul>
                <li>
                    Selection sort has a time complexity of O(n^2) in the worst and average case.
                </li>
                <li>
                    Does not work well on large datasets.
                </li>
                <li>
                    Does not preserve the relative order of items with equal keys which means it is not stable.
                </li>
            </ul>
            <h4>Complexity Analysis of Selection Sort:</h4>
            
            <ul>The time complexity of Selection Sort is O(N2) as there are two nested loops:
                <li>
                    One loop to select an element of Array one by one = O(N)
                </li>
                <li>
                    Another loop to compare that element with every other Array element = O(N)
                </li>
                <li>
                    Therefore overall complexity = O(N) * O(N) = O(N*N) = O(N^2)
                </li>
                <li>
                    Auxiliary Space: O(1) as the only extra memory used is for temporary variables while swapping two values in Array. The selection sort never makes more than O(N) swaps and can be useful when memory writing is costly. 
                </li>
            </ul>
            <a href="https://www.geeksforgeeks.org/selection-sort/"><button>More about the algorithm</button></a>
        </div>
    </div>

    <div class="box">
        <h3>Insertion Sort</h3>
        <div class="content">
            Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.
            <h4>Characteristics of Insertion Sort</h4>
            <ul>
                <li>
                    This algorithm is one of the simplest algorithms with a simple implementation
                </li>
                <li>
                    Basically, Insertion sort is efficient for small data values
                </li>
                <li>
                    Insertion sort is adaptive in nature, i.e. it is appropriate for data sets that are already partially sorted.
                </li>
                
            </ul>
            <h4>Complexity Analysis of Insertion Sort:</h4>
            
            <ul>
                <li>
                    The worst-case time complexity of the Insertion sort is O(N^2)
                </li>
                <li>
                    The average case time complexity of the Insertion sort is O(N^2)
                </li>
                <li>
                    The average case time complexity of the Insertion sort is O(N^2)
                </li>
                <li>
                    The auxiliary space complexity of Insertion Sort is O(1)
                </li>
            </ul>
            <a href="https://www.geeksforgeeks.org/insertion-sort/"><button>More about the algorithm</button></a>
        </div>
    </div>
    <div class="box">
        <h3>Merge Sort</h3>
        <div class="content">
            Merge sort is defined as a sorting algorithm that works by dividing an array into smaller subarrays, sorting each subarray, and then merging the sorted subarrays back together to form the final sorted array.
            <h4>Applications of Merge Sort:</h4>
            <ul>
                <li>
                    Sorting large datasets: Merge sort is particularly well-suited for sorting large datasets due to its guaranteed worst-case time complexity of O(n log n).
                </li>
                <li>
                    External sorting: Merge sort is commonly used in external sorting, where the data to be sorted is too large to fit into memory.
                </li>
                <li>
                    Custom sorting: Merge sort can be adapted to handle different input distributions, such as partially sorted, nearly sorted, or completely unsorted data.
                </li>
                <li>
                    Inversion Count Problem
                </li>
            </ul>
            <h4>Disadvantages of Merge Sort:</h4>
            <ul>
                <li>
                    Space complexity: Merge sort requires additional memory to store the merged sub-arrays during the sorting process. 
                </li>
                <li>
                    Not in-place: Merge sort is not an in-place sorting algorithm, which means it requires additional memory to store the sorted data. This can be a disadvantage in applications where memory usage is a concern.
                </li>
                <li>
                    Not always optimal for small datasets: For small datasets, Merge sort has a higher time complexity than some other sorting algorithms, such as insertion sort. This can result in slower performance for very small datasets.
                </li>
            </ul>
            <h4>Complexity Analysis of Merge Sort:</h4>
            
            <ul>
                <li>
                    Time Complexity: O(N log(N)),  Merge Sort is a recursive algorithm and time complexity can be expressed as following recurrence relation. 
                </li>
            </ul>
            <a href="https://www.geeksforgeeks.org/merge-sort/"><button>More about the algorithm</button></a>
        </div>
    </div>
    <div class="box">
        <h3>Quick Sort</h3>
        <div class="content">
            Selection sort is a simple and efficient sorting algorithm that works by repeatedly selecting the smallest (or largest) element from the unsorted portion of the list and moving it to the sorted portion of the list. 
            <h4>Advantages of Quick Sort:</h4>
            <ul>
                <li>
                    It is a divide-and-conquer algorithm that makes it easier to solve problems.
                </li>
                <li>
                    It is efficient on large data sets.
                </li>
                <li>
                    It has a low overhead, as it only requires a small amount of memory to function.
                </li>
                
            </ul>
            <h4>Disadvantages of Quick Sort:</h4>
            <ul>
                <li>
                    It has a worst-case time complexity of O(N2), which occurs when the pivot is chosen poorly.
                </li>
                <li>
                    It is not a good choice for small data sets.
                </li>
                <li>
                    It is not a stable sort, meaning that if two elements have the same key, their relative order will not be preserved in the sorted output in case of quick sort, because here we are swapping elements according to the pivot’s position (without considering their original positions).Does not preserve the relative order of items with equal keys which means it is not stable.
                </li>
            </ul>
            <h4>Complexity Analysis of Quick Sort:</h4>
            
            <ul>
                <li>
                    Best Case:  Ω (N log (N))
                </li>
                <li>
                    Average Case:  θ ( N log (N))
                </li>
                <li>
                    Worst Case: O(N2)
                </li>
            </ul>
            <a href="https://www.geeksforgeeks.org/quick-sort/" type="btn"><button>More about the algorithm</button></a>
        </div>
    </div>
</body>
</html>